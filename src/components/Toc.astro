---
import type { MarkdownHeading } from 'astro'

type Props = { headings: MarkdownHeading[] }

interface TocItem extends MarkdownHeading {
  children: TocItem[]
}

const { headings }: Props = Astro.props

/**
 * 将扁平的 headings 数组转换为树状结构
 * 支持 h1 - h5 任意层级
 */
function buildToc(headings: MarkdownHeading[]) {
  const root: TocItem = { depth: 0, text: '', slug: '', children: [] }
  const stack = [root]

  for (const h of headings) {
    // 只要当前标题深度小于或等于栈顶深度，就出栈，直到找到父节点
    while (stack[stack.length - 1].depth >= h.depth) {
      stack.pop()
    }
    const newItem = { ...h, children: [] }
    stack[stack.length - 1].children.push(newItem)
    stack.push(newItem)
  }
  return root.children
}

const tocTree = buildToc(headings)
const has = tocTree.length > 0

/** 辅助函数：递归渲染树 */
function renderToc(items: TocItem[]): string {
  if (!items.length) return ''
  return `
    <ul class="space-y-1 ${items[0].depth > 1 ? 'pl-4' : ''}">
      ${items
        .map(
          item => `
        <li class="text-sm leading-tight">
          <a href="#${item.slug}" class="toc-link toc-h${item.depth}" data-depth="${item.depth}">
            ${item.text}
          </a>
          ${renderToc(item.children)}
        </li>
      `,
        )
        .join('')}
    </ul>
  `
}
---

{
  has && (
    <div class='toc-root'>
      {/* 移动端：内嵌 */}
      <nav class='toc toc-inline' aria-label='Table Of Contents'>
        <details open>
          <summary class='text-sm font-semibold'>Table of Contents</summary>
          <div class='mt-4 ml-4'>
            <Fragment set:html={renderToc(tocTree)} />
          </div>
        </details>
      </nav>

      {/* 桌面端：右侧浮动 */}
      <aside class='toc-float'>
        <nav class='toc' aria-label='Table Of Contents'>
          <details open>
            <summary class='text-sm font-semibold'>Table of Contents</summary>
            <div class='mt-2'>
              <Fragment set:html={renderToc(tocTree)} />
            </div>
          </details>
        </nav>
      </aside>
    </div>
  )
}

<script is:inline data-astro-rerun>
  ;(() => {
    const ready = fn => {
      if (document.readyState === 'loading')
        document.addEventListener('DOMContentLoaded', fn, { once: true })
      else fn()
    }

    function boot() {
      const root = document.querySelector('.toc-root')
      if (!root) return

      const float = root.querySelector('.toc-float')
      const atTop = () => window.scrollY <= 2
      const onScroll = () => {
        float?.classList.toggle('at-top', atTop())
      }
      onScroll()
      window.addEventListener('scroll', onScroll, { passive: true })

      const article = document.querySelector('article[data-pagefind-body]')
      if (!article) return

      // 更新选择器：支持 h1 到 h5
      const heads = [
        ...article.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id]'),
      ]
      if (!heads.length) return

      const allLinks = [...root.querySelectorAll('.toc a.toc-link')]
      const map = new Map()
      for (const a of allLinks) {
        const href = a.getAttribute('href') || ''
        if (!href.startsWith('#')) continue
        const id = href.slice(1)
        if (!map.has(id)) map.set(id, [])
        map.get(id).push(a)
      }

      let activeId = null
      const setActive = id => {
        if (activeId === id) return
        if (activeId && map.has(activeId))
          map.get(activeId).forEach(el => el.classList.remove('is-active'))
        activeId = id
        if (activeId && map.has(activeId))
          map.get(activeId).forEach(el => el.classList.add('is-active'))
      }

      const io = new IntersectionObserver(
        entries => {
          const visible = entries
            .filter(e => e.isIntersecting)
            .sort((a, b) => a.boundingClientRect.top - b.boundingClientRect.top)
          if (visible.length) {
            setActive(visible[0].target.id)
          } else {
            const nearest = heads
              .map(h => ({
                id: h.id,
                top: Math.abs(h.getBoundingClientRect().top),
              }))
              .sort((a, b) => a.top - b.top)[0]
            if (nearest) setActive(nearest.id)
          }
        },
        { root: null, threshold: [0, 1], rootMargin: '-96px 0px -60% 0px' },
      )

      heads.forEach(h => io.observe(h))

      const onClick = e => {
        const a = e.target.closest('.toc a.toc-link')
        if (!a) return
        const href = a.getAttribute('href') || ''
        if (!href.startsWith('#')) return
        const id = href.slice(1)
        const el = document.getElementById(id)
        if (!el) return
        e.preventDefault()
        el.scrollIntoView({ behavior: 'smooth', block: 'start' })
      }
      root.addEventListener('click', onClick)

      const cleanup = () => {
        window.removeEventListener('scroll', onScroll)
        io.disconnect()
        root.removeEventListener('click', onClick)
      }
      document.addEventListener('astro:before-swap', cleanup, { once: true })
    }

    ready(boot)
    document.addEventListener('astro:page-load', boot)
  })()
</script>

<style is:global>
  /* 确保所有层级的锚点都有偏移 */
  article[data-pagefind-body] :is(h1[id], h2[id], h3[id], h4[id], h5[id]) {
    scroll-margin-top: 96px;
  }
</style>

<style>
  /* ...原有显示规则保持不变... */
  .toc-root .toc-inline {
    display: block;
  }
  .toc-root .toc-float {
    display: none;
  }
  @media (min-width: 1200px) {
    .toc-root .toc-inline {
      display: none;
    }
    .toc-root .toc-float {
      display: block;
    }
  }

  .toc-root .toc details {
    padding: 1rem;
    border-radius: 10px;
    border: 1px solid #83838330;
    margin-bottom: 1rem;
  }

  .toc-root .toc-float {
    position: fixed;
    top: 84px;
    right: max(12px, env(safe-area-inset-right));
    width: 260px;
    max-height: 78vh;
    overflow: auto;
    z-index: 40;
    transition:
      opacity 0.25s ease,
      transform 0.25s ease;
  }
  .toc-root .toc-float.at-top {
    opacity: 0;
    pointer-events: none;
    transform: translateY(-4px);
  }

  /* 链接基础样式 */
  .toc-root .toc a.toc-link {
    position: relative;
    display: block;
    padding: 0.125rem 0;
    color: #6b7280;
    text-decoration: none;
    transition: color 0.15s ease;
  }
  .dark .toc-root .toc a.toc-link {
    color: #a1a1aa;
  }

  .toc-root .toc a.toc-link:hover {
    color: #3f3f46;
  }
  .dark .toc-root .toc a.toc-link:hover {
    color: #e4e4e7;
  }

  /* 激活状态指示点 */
  .toc-root .toc a.toc-link.is-active::before {
    content: '';
    position: absolute;
    left: -12px;
    top: 0.6em;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: currentColor;
  }

  /* 不同深度的微调 */
  .toc-root .toc a[data-depth='1'] {
    font-weight: 600;
  }
  .toc-root .toc a[data-depth='3'],
  .toc-root .toc a[data-depth='4'],
  .toc-root .toc a[data-depth='5'] {
    opacity: 0.8;
    font-size: 0.9em;
  }

  .toc-root .toc-float .toc details {
    padding: 0.75rem;
    border: 1px solid rgba(0, 0, 0, 0.08);
    background-color: rgba(0, 0, 0, 0.03);
  }
  .dark .toc-root .toc-float .toc details {
    border-color: rgba(255, 255, 255, 0.08);
    background-color: rgba(255, 255, 255, 0.04);
  }
</style>
